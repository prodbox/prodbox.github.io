import{_ as l,D as o,c as t,b as d,w as e,a2 as E,a1 as s,o as i,I as n,a as r}from"./chunks/framework.DjA6K2Mq.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"interview/redis/multi-threading.md","filePath":"interview/redis/multi-threading.md"}'),c={name:"interview/redis/multi-threading.md"},h=s('<h3 id="_1-redis6-0为什么要使用多线程-io" tabindex="-1">1. Redis6.0为什么要使用多线程(IO)？ <a class="header-anchor" href="#_1-redis6-0为什么要使用多线程-io" aria-label="Permalink to &quot;1. Redis6.0为什么要使用多线程(IO)？&quot;">​</a></h3><hr><blockquote><ul><li>引入多线程的目的是为了提高网络IO读取、写入速度,多线程肯定比单线程要快很多</li><li>默认情况下 I/O 多线程只针对发送响应数据，并不会以多线程的方式处理读请求</li></ul></blockquote><h4 id="_1-1-i-o多线程原理" tabindex="-1">1.1 I/O多线程原理 <a class="header-anchor" href="#_1-1-i-o多线程原理" aria-label="Permalink to &quot;1.1 I/O多线程原理&quot;">​</a></h4><ul><li><code>主线程</code> 监听 <code>epoll/kqueue</code> 将客户端写入<code>server.clients_pending_read</code> [全局读取队列]</li><li><code>主线程</code> 轮训分配客户端到各<code>I/O线程</code>各自任务队列 <code>io_threads_list</code> 解析指令</li><li><code>主线程</code> 等待I/O线程指令全部解析完成，由 <code>主线程</code> 循环执行客户端指定处理函数</li><li><code>主线程</code> 全部执行完成后，会将客户端写入 <code>server.clients_pending_write</code> [全局响应队列]</li><li><code>主线程</code> 轮训分配客户端到各<code>I/O线程</code>各自任务队列，调用网络接口写入响应数据</li></ul>',5),A=s(`<h4 id="_1-2-读请求启用多线程" tabindex="-1">1.2 读请求启用多线程 <a class="header-anchor" href="#_1-2-读请求启用多线程" aria-label="Permalink to &quot;1.2 读请求启用多线程&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 读请求也使用io多线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">threads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-do-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reads yes </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">threads </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span></span></code></pre></div><h3 id="_2-redis后台线程有哪些-做什么的" tabindex="-1">2. Redis后台线程有哪些？做什么的？ <a class="header-anchor" href="#_2-redis后台线程有哪些-做什么的" aria-label="Permalink to &quot;2. Redis后台线程有哪些？做什么的？&quot;">​</a></h3><ul><li><code>Redis-server</code> ： 主线程，主要负责执行命令，也属于I/O线程；</li><li><code>bio_close_file</code>： 异步处理关闭文件任务</li><li><code>bio_aof_fsync</code>： 异步AOF刷盘任务</li><li><code>bio_lazy_free</code>：异步释放内存任务</li><li><code>io_thd_1</code>：I/O 线程</li><li><code>io_thd_2</code>：I/O 线程</li><li><code>io_thd_3</code>：I/O 线程</li></ul>`,4);function _(p,B,k,u,m,g){const a=o("Mermaid");return i(),t("div",null,[h,(i(),d(E,null,{default:e(()=>[n(a,{id:"mermaid-48",class:"mermaid",graph:"sequenceDiagram%0AaeMain-%3E%3EaeProcessEvents%3A%20while%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%0AaeProcessEvents--%3E%3Ebeforesleep%3A%20%E2%91%A0%20%E5%A4%84%E7%90%86%E4%B8%8A%E6%AC%A1%E5%B7%B2%E8%A7%A6%E8%BE%BE%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%EF%BC%8C%3Cbr%3E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%0AaeProcessEvents--%3E%3EaeApiPoll%3A%20%E2%91%A1%20%E9%98%BB%E5%A1%9E%E4%B8%80%E5%AE%9A%E6%97%B6%E9%97%B4%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%B7%B2%E8%A7%A6%E8%BE%BE%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%20numevents%0AaeProcessEvents--%3E%3Eaftersleep%3A%20%E2%91%A2%20%E5%85%88%E5%BF%BD%E7%95%A5%0Aaftersleep-%3E%3EaeProcessEvents%3A%20%E2%91%A3%20%E5%BE%AA%E7%8E%AF%E4%B8%8B%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%0A"})]),fallback:e(()=>[r(" Loading... ")]),_:1})),A])}const f=l(c,[["render",_]]);export{b as __pageData,f as default};
